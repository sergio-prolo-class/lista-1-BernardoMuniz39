/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Scanner;
//linha por linha sc.hasNextLine()
//palavra por palavra sc.hashNext
public class App {

    //Uma variável global para a validação. Minha ideia aqui é que se caso algumas das funções de validação forem chamadas e por algum acaso entrar dentro de alguma condicional, ela é incrementada.
    //Se passar por todos as condicionais sem ser incrementada, então o tabuleiro é válido
    static int tabuleiroValido = 0;

    static String[] validaDimensao (){
        int  i =0;
        Scanner entrada = new Scanner(System.in);
        String [] palavras = new String[150];

        while(entrada.hasNext()){
            palavras[i++] = entrada.next();
        }
       
        if(i != 100){
            System.out.println("Tabuleiro com dimensão inválida!");
            tabuleiroValido++;
        }
   
        return palavras;
    }

    //valida se existe outros navios dentro do tabuleiro
    static String[] ValidaNavios(){
        String [] palavras = validaDimensao();
        int conhecidos = 1; //PARTE DO PRINCIPIO QUE TODOS OS NAVIOS SÃO CONHECIDOS

    

        //Verificando se possui navios desconehcidos
        for(int j = 0; j < palavras.length; j++){
            String p = palavras[j];

            if(p == null)continue;

            if(!(p.equals("C") || p.equals("S") || p.equals("P") || p.equals("N") || p.equals("E") || p.equals("."))){
                conhecidos = 0;
            }
        }

        if(conhecidos == 0){
            System.out.println("Tabuleiro com outros navios!");
            tabuleiroValido++;
        }

        return palavras;
        }

        //A função vai validar se na matriz passada existe ao menos um caracter do tipo C, S, P, N e E
        static String[] ValidaNavioDeCadaTipo(){
            String [] palavras = ValidaNavios();
            int qtdC = 0, qtdS = 0, qtdP =0, qtdN = 0, qtdE = 0;

            for(int i = 0; i < palavras.length; i++){
                String p = palavras[i];
                if(p == null)continue;

                switch (p) {
                    case "C": qtdC++; break;
                    case "E": qtdE++; break;
                    case "S": qtdS++; break;
                    case "P": qtdP++; break;
                    case "N": qtdN++; break;
                }
            }

            boolean validacao = qtdC < 1 || qtdE < 1 || qtdS < 1 || qtdP < 1 || qtdN < 1;  //SE ALGUM POSSUIR QUANTIDADE IGUAL A 0 => RETORNA TRUE
            boolean validacao2 = qtdC > 3 || qtdE > 4 || qtdS > 3 || qtdP > 5 || qtdN > 2; //SE ALGUM POSSUIR MULTIPLOS NAVIOS DO MESMO TIPO ==> RETORNA TRUE
            boolean validacao3 = qtdC < 3 || qtdE < 4 || qtdS < 3 || qtdP < 5 || qtdN < 2; //para o caso de possui navios de cada tipo e não possui multiplos navios, mas sim navios insuficientes
            if(validacao){
                System.out.println("Tabuleiro não inclui um navio de cada tipo!");
                tabuleiroValido++;
                
            }

            if(validacao2){
                    System.out.println("Tabuleiro possui múltiplos navios do mesmo tipo!");
                    tabuleiroValido++;
            }

            if(validacao3){
                System.out.println("Tabuleiro possui navios insuficientes!");
                tabuleiroValido++;
            }
            return palavras;
            
        }



        static boolean horizontal(String[] palavras, String caracter){
            boolean horizontal = false;
        
            for (int i = 0; i < palavras.length; i++) { 
                if(palavras[i] == null || palavras[i +1] == null)continue;
                if (palavras[i].equals(caracter) && palavras[i + 1].equals(caracter)) {
                    horizontal = true;
                }
            }

           return horizontal;
        
        }

        static boolean vertical(String[] palavras, String caracter, int largura) {
            for (int i = 0; i < palavras.length - largura; i++) {
                if(palavras[i] == null || palavras[i + largura] == null)continue;
                if (palavras[i].equals(caracter) && palavras[i + largura].equals(caracter)) {
                    return true;
                }
            }
            return false;
        }
    
        static boolean HorizontalVertical(){
            String [] palavras = ValidaNavioDeCadaTipo();
            boolean C = vertical(palavras, "C", 10) || horizontal(palavras, "C");
            boolean N = vertical(palavras, "N", 10) || horizontal(palavras, "N");
            boolean P = vertical(palavras, "P", 10) || horizontal(palavras, "P");
            boolean S = vertical(palavras, "S", 10) || horizontal(palavras, "S");
            boolean E = vertical(palavras, "E", 10) || horizontal(palavras, "E");


            if(!(C && N && P && S && E)){
                System.out.println("Tabuleiro possui navios que não estão na horizontal ou vertical!");
                tabuleiroValido++;
            }

            if(tabuleiroValido == 0){
                return true;
            }

            return false;

        }

    public static void main(String[] args) {
        
        if(HorizontalVertical()){
            System.out.println("Tabuleiro válido");
        }
        
    }
}